= Curso iOS
Creado por Rodrigo Francisco <rhodfra@gmail.com>
Version 1.0, 12.03.2021
//:keywords: 
//:sectnums: 
// Configuracion de la tabla de contenidos
:toc: 
:toc-placement!:
:toclevels: 4                                          
:toc-title: Contenido

// Ruta base de las imagenes
:imagesdir: ./README.assets/ 

// Resaltar sintaxis
:source-highlighter: pygments

// Iconos para entorno local
ifndef::env-github[:icons: font]

// Iconos para entorno github
ifdef::env-github[]
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]

toc::[]

Apuntes del diplomado de iOS 

== Notas rápidas

Para aprender a desarrollar aplicaciones para iOS se necesita tener instalado 
https://developer.apple.com/xcode/[xcode]

Y adicionalmente para correr programas de _Swift_ o usar _git_ en la terminal 
se requiere tener instaladas las herramientas de desarrollo (Commande Line 
Tools) de xcode

[source,sh]
xcode-select --install

.Ligas útiles para _commandLineTools_ 
* https://ma.ttias.be/mac-os-xcrun-error-invalid-active-developer-path-missing-xcrun/


== Repositorios de referencia

* https://github.com/crashbit/diplomado-5g[Germán Santos: Diplomado-5g]
* https://github.com/galigaribaldi/Diplomado_IOS[Gali: Diplomado-IOS]
* https://github.com/galigaribaldi/Codigos_swift[Gali: Codigos-Swift]
* https://github.com/SamArtGS/iOS[Sam:iOS]

== Roadmap 

image::road.png[]

== Particularidades del lenguaje

A continuación se describen algunas características interesantes de  _Swift_,
probablemente esta sección se reorganize posteriormente.

=== Optional binding

_Optional binding_ permite encontrar su una _variable opcional_ contiene algún
valor, de ser así, este se pone disponiblem mediante una *constante* o variable
*temporal*

La técnica de optional binding se puede usar en `if`'s y en `while`'s

[source,swift]
----
if let actualNumber = Int(possibleNumber) {
  print("Se pudo hacer el parseo")
  print("Ahora puedo usar el valor como actualNumber: \(actualNumber)")
} else {
  print("No se pudo realizar el parseo")
}
----

Se pueden poner varios _Optional binding_, cada uno separado por *comas*. Cada
coma se puede traducir a un "and"

[source,swift]
----
# Este snipet se vuelve inecesariamenent díficil de leer
if let firstNumber = Int("4") {
  if let secondNumber = Int("42") {
    if firstNumber < secondNumber && secondNumber < 100 {
      print("\(firstNumber) < \(secondNumber) < 100")
    }
  }
}

# CORRECCIÓN
if let firstNumber = Int("4"), 
let secondNumber = Int("42"), 
firstNumber < secondNumber && secondNumber < 100 {
  print("\(firstNumber) < \(secondNumber) < 100")
}

----


=== Nil-Coalescing Operator (`a ?? b`)

No he encontrado la traducción más adecuada pero, este operador hace lo
siguiente.

_Desenvuelve_ un optional si es que contiene un valor, en caso contrario regresa
el valor por defecto (`b`).

El operador _nil-coalescing_ es un abreviación del código que se muestra a
continuación

[source,swift]
a != nil ? a! : b

*Ejemplo*

[source,sh]
----
let defaultColor = "red"
var userColor: String? //<1>

//Uso del operador
var layoutColor = userColor ?? defaultColor // <2>
----
<1> Se declara como opcional y como no se le asigna un valor, por defecto se
inicializa con `nil`
<2> La variable se inicializa con el color "red"


=== Rangos

Enumero las características que me parecieron relevantes y que algunos lenguajes
manejan, pero otros no.

* Rangos con _intervalo cerrado_
* Rangos con _intervalo abierto_
* Rangos de 1 solo lado (`names[2...]`)
* Rangos "infinitos" (`range = [0...]`)

=== Strings (Cadenas)

La característica más destacable es que _Swift_ utiliza *interpolación* de una
manera muy sencilla.

=== Arreglos

[source,swift]
----
// Reemplazando 3 elementos del arreglo con solo 2: "Bananas" y "Apples"
shoppingList[4...6] = ["Bananas", "Apples"]
----

=== Diccionarios

[source,swift]
-----
// Inicializando un diccionario
var namesOfIntegers = [Int: String]()
// Una forma de vaciar el diccionario
var namesOfIntegers2 = [:]
// Agregando un valor al diccionario
namesOfIntegers[16] = "sixteen"
-----

=== Switch

La sentencia `switch` es una de las sentencias más versátiles de Swift. `case`
puede recibir 

* Rangos, 
* Tuplas
* E inclusive puedes hacer _value binding_

[NOTE]
Notar que la palabra `break` no es necesaria en comparación con otros lenguajes
como C.

*Ejemplo de switch con tuplas*

[source,swift]
----
let somePoint = (1, 1)
switch somePoint {
case (0, 0):
  print("\(somePoint) is at the origin")
case (_, 0):
  print("\(somePoint) is on the x-axis")
case (0, _):
  print("\(somePoint) is on the y-axis")
case (-2...2, -2...2):
  print("\(somePoint) is inside the box")
default:
  print("\(somePoint) is outside of the box")
}
// Prints "(1, 1) is inside the box"
----

=== Guard (Salida anticipada)

Una sentencia `guard` es _muy_ similiar a un `if`. Sin embargo, se enlistan
algunas particularidades:

* La sentencia `guard` *siempre* se acompaña de la clausula `else`
* La sentencia `guard`, al igual que el `if`, requiere de una _condición
booleana_ para trabajar.

==== Casos de uso

Para desenvolver opcionales.

*Caso práctico*

Tenemos una función y en caso de que algún opcional tenga el valor `nil` podemos
terminar la función y regresar el control.


[source,swift]
----
func greet(person: [String: String]) {
  guard let name = person["name"] else {
    return
  }

  print("Hello \(name)!")

    guard let location = person["location"] else {
      print("I hope the weather is nice near you.")
        return
    }

  print("I hope the weather is nice in \(location).")
}

greet(person: ["name": "John"])
// Prints "Hello John!"
// Prints "I hope the weather is nice near you."
greet(person: ["name": "Jane", "location": "Cupertino"])
// Prints "Hello Jane!"
// Prints "I hope the weather is nice in Cupertino."
----
